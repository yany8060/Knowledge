### 排序算法

#### 经典排序算法
* 冒泡排序
* 插入排序
* 选择排序
* 快速排序
* 归并排序
* 计数排序
* 基数排序
* 桶排序



#### 分析排序算法

* 排序算法的执行效率
    * 最好情况、最坏情况、平均请求的时间复杂度
    * 时间复杂度的系数、常数、低价：数据规模小，对统一阶时间复杂度的排序算法性能比较的时候，需要考虑系数、常数、低价
    * 比较次数和交换（或移动）次数
* 排序算法的内存消耗：空间复杂度的比较；原地排序算法，就是特指空间复杂度是O(1)的排序算法。
* 排序算法的稳定性：如果排序的序列中存在相等的元素，经过排序之后，相等元素之间原有的先后顺序不变

#### 冒泡排序

##### 特性
* 冒泡排序是原地排序算法，
* 冒泡排序是是稳定的排序算法
* 冒泡排序的时间复杂度：最好时间复杂度O(n)、最坏情况时间复杂度O(n2)、平均时间复杂度O(n2)

#### 插入排序
##### 算法
1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 新元素插入到该位置后
6. 重复步骤2~5

> 如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找插入排序。

##### 特性
* 插入排序是原地排序算法，
* 插入排序是是稳定的排序算法
* 插入排序的时间复杂度：最好时间复杂度O(n)、最坏情况时间复杂度O(n2)、平均时间复杂度O(n2)

#### 选择排序

##### 特性
* 选择排序是原地排序算法
* 选择排序不是稳定排序排序
* 选择排序的时间复杂度：最好时间复杂度O(n)、最坏情况时间复杂度O(n2)、平均时间复杂度O(n2)



#### 归并排序
递推公式： merge_sort(l...r) = merge_sort(merge_sort(l...mid), merge_sort(mid+1...r))，终止条件 l >= r

##### 算法
1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择较小的元素放入到合并空间，并移动指针到下一个位置
4. 重复步骤3直到某一个指针达到序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾

##### 特性
* 归并排序空间复杂度：O(n2)
* 归并排序是稳定排序排序
* 归并排序的时间复杂度：最好时间复杂度O(nlogn)、最坏情况时间复杂度O(nlogn)、平均时间复杂度O(nlogn)

#### 快速排序

##### 算法
1. 挑选基准值：从数列中挑出一个元素，称为“基准”（pivot）
2. 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成
3. 递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序